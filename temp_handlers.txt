    // --- RECORDING HANDLERS ---
    const handleRecordingComplete = async (
        audioDataUrl: string,
        durationSeconds: number,
        customTitle: string,
        notes: NoteItem[],
        media: MediaItem[],
        audioBlob?: Blob
    ): Promise<Recording> => {
        if (!supabaseUser) throw new Error('No user logged in');

        // Upload audio to storage if we have a blob
        let audioUrl = audioDataUrl;
        if (audioBlob) {
            const uploadedUrl = await uploadAudio(audioBlob, supabaseUser.id);
            if (uploadedUrl) audioUrl = uploadedUrl;
        }

        // Create new recording object
        const h = Math.floor(durationSeconds / 3600).toString().padStart(2, '0');
        const m = Math.floor((durationSeconds % 3600) / 60).toString().padStart(2, '0');
        const s = Math.floor(durationSeconds % 60).toString().padStart(2, '0');
        
        const newRecording: Recording = {
            id: '', // Will be set by database
            folderId: null,
            title: customTitle || 'Nueva Grabaci\u00f3n',
            description: '',
            date: new Date().toLocaleString('es-ES'),
            duration: ${h}::,
            durationSeconds,
            status: 'Pending',
            tags: [],
            participants: 0,
            audioUrl,
            summary: null,
            segments: [],
            notes,
            media
        };

        // Save to database
        const createdRecording = await databaseService.createRecording(newRecording);
        if (!createdRecording) throw new Error('Failed to create recording');

        // Update local state
        setRecordings(prev => [createdRecording, ...prev]);
        setActiveRecordingId(createdRecording.id);

        return createdRecording;
    };

    const handleUpdateRecording = async (id: string, updates: Partial<Recording>): Promise<void> => {
        await databaseService.updateRecording(id, updates);
        
        // Update local state
        setRecordings(prev =>
            prev.map(rec => rec.id === id ? { ...rec, ...updates } : rec)
        );
    };

